%% PLATYPUS - Meeting Eight

% Let's start with the unary encoding of natural numbers.

%% Let's build the abstract syntax for the terms of the language E from PFPL
%% (2nd), 4.1. We'll use HOAS to represent the binding struture of the let
%% operator.

%% Our language has a single sort: expressions.
EXP : type.

%% Constructors for atomic values.
num : nat -> EXP.
str : string -> EXP.

plus : EXP -> EXP -> EXP.
mult : EXP -> EXP -> EXP.
cat  : EXP -> EXP -> EXP.
len  : EXP -> EXP.
let  : EXP -> (EXP -> EXP) -> EXP.

%% Types

TYPE : type.
numt : TYPE.
strt : TYPE.

%% Typing
%%
%% The oftp type represents the typing judgement defined by the rules 4.1 in
%% PFPL (2nd) pp 36-37.

oftp : EXP -> TYPE -> type.

oftp/num : oftp (num N) numt.

oftp/str : oftp (str S) strt.

oftp/let : oftp (let E1 E2) T2
	    <- oftp E1 T1
	    <- {x : EXP} (oftp x T1 -> oftp (E2 x) T2).

oftp/plus : oftp (plus E1 E2) numt
	     <- oftp E1 numt
	     <- oftp E2 numt.

oftp/mult : oftp (mult E1 E2) numt
	     <- oftp E1 numt
	     <- oftp E2 numt.

oftp/cat : oftp (cat E1 E2) strt
	    <- oftp E1 strt
	    <- oftp E2 strt.

oftp/len : oftp (len E) numt
	    <- oftp E strt.

%% Evaluation
%%

val : EXP -> type.
%mode val +E.

val/num : {N:nat} val (num N).
val/str : {S:string} val (str S).

%worlds () (val _).

eval : EXP -> EXP -> type.
%mode eval +E1 -E2.

eval\plus-l : eval (plus N M) (plus (num N1) M) <- eval N (num N1).
eval\plus-r : eval (plus (num N) M) (plus (num N) (num M1))
	       <- eval M (num M1).
eval\plus   : eval (plus (num N) (num M)) (num O)
	       <- add N M O.

eval\mult-l : eval (mult N M) (mult (num N1) M)
	       <- eval N (num N1).
eval\mult-r : eval (mult (num N) M) (mult (num N) (num M1))
	       <- eval M (num M1).
eval\mult   : eval (mult (num N) (num M)) (num P)
	       <- times N M P.

eval\cat-l : eval (cat S T) (cat (str S1) T)
	      <- eval S (str S1).
eval\cat-r : eval (cat (str S) T) (cat (str S) (str T1))
	      <- eval T (str T1).
eval\cat   : eval (cat (str S) (str T)) (str U)
	      <- concat S T U.

eval\len-l : eval (len S) (len (str S1)) <- eval S (str S1).
eval\len : eval (len (str S)) (num N) <- length S N.

%{
eval\let-xs : eval (let E F) (let (str E1) F) <- eval E (str E1).
eval\let-xn : eval (let E F) (let (num E1) F) <- eval E (num E1).
eval\let-s  : eval (let (str E) F) F1 <- eval (F (str E)) F1.
eval\let-n  : eval (let (num E) F) F1 <- eval (F (num E)) F1.
}%

eval\let : eval (let E F) F1 <- eval (F E) F1.

eval\num : eval (num V) (num V).
eval\str : eval (str V) (str V).

%mode eval +E -V.
%worlds () (eval _ _).
%total E (eval E _).

%% Let's run some queries to make sure that all of the things defined above
%% work. I'll do this here to make sure I haven't silently shaddowed anything
%% on the way through.

%query 1 1 add (succ (succ (succ zero))) (succ zero) N.
%query 1 1 times (succ (succ zero)) (succ (succ zero)) N.
%query 1 1 oftp (cat (str empty) (str empty)) T.
%query 1 1 oftp (let (str empty) ([x] (len x))) T.
